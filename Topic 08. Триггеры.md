### Триггеры

#### Теор. справка

**Хранимый код** – **объект базы данных**, представляющий собой **набор SQL-инструкций** (и не только их), который **компилируется один раз и хранится на сервере**.

Позволяет:

* Скрывать алгоритмы обработки данных
* Расширить возможности программирования, реализовывать сложную логику
* Поддерживать функции безопасности и целостности данных, обработку исключений

PostgreSQL позволяет разрабатывать собственный хранимый код **в том числе** и на, так называемых, процедурных языках. Они не включены в стандартный сервер PostgreSQL и предлагаются загружаемыми модулями:

* PL/pgSQL
* PL/Tcl
* PL/Perl
* PL/Python

**PL/pgSQL** - язык программирования для написания хранимого кода для PostgreSQL. Позволяет писать:

* Выполняемые блоки
* Функции
* Триггеры - особый объект баз данных

#### Функции

PostgreSQL предоставляет **большое количество функций** для **встроенных** типов данных.

##### Определение собственной функции

```postgresql
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS 'тело функции'
LANGUAGE [SQL|plpgsql|plpython|...];
```

**Примечание!**

Если рассматривать `CREATE FUNCTION`, **тело функции** представляет собой **просто текстовую строку**. Часто для написания тела функции **удобнее заключать** эту строку **в доллары**, а не в обычные апострофы. Если не применять заключение в доллары, **все апострофы или обратные косые черты** в теле функции **придётся экранировать**, дублируя их.

**Строковые константы в долларах** можно **вкладывать** друг в друга, **выбирая** на разных уровнях **разные теги**. **Чаще всего** это используется при написании **определений функций**. Например:

```postgresql
$function$ -- тег function
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);  -- тег q
END;
$function$
```

#### Функции на SQL

Это простейший вариант функций. Пишется на языке запросов (т.е. на SQL).

Примеры:

```postgresql
-- Пример №1
CREATE FUNCTION add(integer, integer) 
RETURNS integer
AS 'SELECT $1 + $2;'
LANGUAGE SQL;

---- Запрос
SELECT add(1, 3);

--- Ответ
| add |
-------
|  4  |
```

```postgresql
-- Пример №2
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
LANGUAGE SQL;

---- Запрос
SELECT * FROM dup(42);

--- Ответ
| f1   | f2         |
---------------------
|   42 | 42 is text |
```

#### Функции на PL/pgSQL

**PL/pgSQL** это блочно-структурированный язык. Текст тела функции должен быть блоком.

##### Структура блока:

```plsql
[ <<метка>> ]
[ DECLARE
    объявления ]
BEGIN
    операторы
END [ метка ];
```

* Каждое объявление и каждый оператор в блоке **должны завершаться** символом `;`.
* Блок, вложенный в другой блок, **должен иметь** точку с запятой после `END`, как показано выше.
* Финальный `END` точки с запятой не требует.
* Ключевые слова **не чувствительны** к регистру символов.



* **Комментарии**:
  * ``--``
  * `/*`, `*/` (блочный комментарий, может быть вложенным)



* **Любой оператор** в выполняемой секции блока **может быть вложенным блоком**.

* Вложенные блоки используются для:

  * **Логической группировки** нескольких операторов
  * **Локализации** области действия переменных для группы операторов

* **Во время выполнения вложенного блока переменные, объявленные в нём, скрывают переменные внешних блоков с такими же именами.**

* Чтобы **получить доступ к внешним переменным**, нужно **дополнить их имена меткой** блока. Например:

  ```plsql
  CREATE FUNCTION somefunc() RETURNS integer AS $$
  << outerblock >>
  DECLARE
      quantity integer := 30;
  BEGIN
      RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 30
      quantity := 50;
      --
      -- Вложенный блок
      --
      DECLARE
          quantity integer := 80;
      BEGIN
          RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 80
          RAISE NOTICE 'Во внешнем блоке quantity = %', outerblock.quantity;  -- Выводится 50
      END;
  
      RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 50
  
      RETURN quantity;
  END;
  $$ LANGUAGE plpgsql;
  ```

  > Примечание
  >
  > Существует **скрытый «внешний блок»**, окружающий тело каждой функции на **PL/pgSQL**. Этот блок содержит объявления параметров функции (если они есть), а также некоторые специальные переменные, такие как `FOUND`. Этот блок имеет метку, совпадающую с именем функции, таким образом, **параметры и специальные переменные могут быть дополнены именем функции**.

Важно не путать использование `BEGIN/END` для группировки операторов в **PL/pgSQL** с одноимёнными SQL-командами для управления транзакциями. `BEGIN/END` в **PL/pgSQL** служат только для группировки предложений; они не начинают и не заканчивают транзакции. Про управление транзакциями в **PL/pgSQL** можно почитать в документации.

Кроме того, **блок с предложением** `EXCEPTION` по сути **создаёт вложенную транзакцию**, которую **можно отменить**, **не затрагивая внешнюю транзакцию**. Подробнее обработка ошибок описана в документации.

#### Функции на PL/Python

##### Установка

Прежде чем что-то использовать, это надо установить. если вы используете контейнер c `postgres` поверх `apline` скачайте пакеты:

```sh
apk add --no-cache --virtual .plpython3-deps --repository http://nl.alpinelinux.org/alpine/edge/testing \
    postgresql-plpython3 \
    && ln -s /usr/lib/postgresql/plpython3.so /usr/local/lib/postgresql/plpython3.so \
    && ln -s /usr/share/postgresql/extension/plpython3u.control /usr/local/share/postgresql/extension/plpython3u.control \
    && ln -s /usr/share/postgresql/extension/plpython3u--1.0.sql /usr/local/share/postgresql/extension/plpython3u--1.0.sql \
    && ln -s /usr/share/postgresql/extension/plpython3u--unpackaged--1.0.sql /usr/local/share/postgresql/extension/plpython3u--unpackaged--1.0.sql
```

После необходимо установить `PL/Python` в определённую базу данных, выполните команду:

```postgresql
CREATE EXTENSION plpython3u; -- будем использовать Python3
```

##### Создание функций

Функции на `PL/Python` **объявляются стандартным образом** с помощью команды `CREATE FUNCTION`:

```postgresql
CREATE FUNCTION funcname (argument-list)
  RETURNS return-type
AS $$
  # Тело функции на PL/Python
$$ LANGUAGE plpython3u;
```

* Тело функции содержит **скрипт Python**.
* Аргументы передаются в виде списка ***args***, именованные аргументы также передаются.
* Возвращает значения (в том числе None) через `return` или `yield`

##### Пример

Функция максимума:

```plsql
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a > b:
    return a
  return b
$$ LANGUAGE plpython3u;
```

**Значения аргументов** задаются в **глобальных** переменных. Согласно правилам видимости в Python, тонким следствием этого является то, что **переменной аргумента нельзя присвоить внутри функции выражение, включающее имя самой этой переменной**, **если только эта переменная не объявлена глобальной в текущем блоке**. Например, следующий код не будет работать:

```plsql
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # ошибка
  return x
$$ LANGUAGE plpython3u;
```

так как присвоение x значения делает x локальной переменной для всего блока, и при этом x в правой части присваивания оказывается ещё не определённой локальной переменной x, а не параметром функции PL/Python. **Добавив оператор** `global`, **это можно исправить**:

```plsql
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # теперь всё в порядке
  return x
$$ LANGUAGE plpython3u;
```

#### Function Volatility Categories

**Каждая** функция имеет свою степень/категорию волатильности: `VOLATILE`, `STABLE`, `IMMUTABLE`. `VOLATILE` **значение по умолчанию** в `CREATE FUNCTION` в команде. Степень волатильности является **контрактом для оптимизатора** про поведение функции:

* `VOLATILE` функция не дает никаких гарантий о своем поведении: поведение может быть недетерминированно при одинаковых аргументах, модифицировать внутренне состояние базы данных, ... . Оптимизатор не делает никаких предположений касаемо поведения такой функции. Запросы, использующие `VOLATILE` функции будут пересчитывать значение функции на каждой применяемой строке таблицы.

* `STABLE` функция дает гарантию, что не модифицирует внутреннее состояние базы и гарантирует детерминированное поведение на одних и тех же аргументах **в рамках одного запроса**. Поэтому данная степень волатильности позволяет оптимизировать множественные вызовы путем кеширования. В частности, такие функции можно использовать для поиска по индексу (для `VOLATILE` такое запрещено).
* `IMMUTABLE` функция дает те же гарантии что и `STABLE`, но снимает ограничение на рамки одного запроса. Поэтому оптимизатор может предварительно "прогреть кэш" на константных аргументах.

Для лучшей эксплуатации оптимизатора **следует использовать** ту допустимую **категорию**, которая **дает больше гарантий о своем поведении**.

Функции модифицирующие состояние БД должны быть обозначены как `VOLATILE`. Функции типа `random()`, `currval()`, `timeofday()` должны быть также обозначены `VOLATILE`.

#### Процедуры

Процедура - объект базы данных, подобный функции, но имеющий следующие отличия:

* Определяются командой `CREATE PROCEDURE`
* Не возвращают значение. Однако могут выдавать данные в вызывающий код через выходные параметры.
* Функции вызываются как часть запроса или команды DML, а процедуры вызываются отдельно командой `CALL`.
* Процедура может фиксировать или откатывать транзакции во время её выполнения (а затем автоматически начинать новую транзакцию), если вызывающая команда `CALL` находится не в явном блоке транзакции.
* Некоторые атрибуты функций (например, `STRICT`) неприменимы к процедурам. Эти атрибуты влияют на вызов функций в запросах и не имеют отношения к процедурам.

##### Пример

```postgresql
CREATE PROCEDURE insert_data(a integer, b integer)
LANGUAGE SQL -- можно также использовать процедурные языки
AS $$
  INSERT INTO tbl VALUES (a);
  INSERT INTO tbl VALUES (b);
$$;
```

```postgresql
CALL insert_data(1, 2);
```

#### Триггеры

Триггер - хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием модификации данных: добавлением `INSERT`, удалением `DELETE` строки в заданной таблице, или изменением `UPDATE` данных в определенном столбце заданной таблицы.

Могут выполняться до / вместо / после основного действия и для всей строки / всего выражения модификации данных.

![img](https://gitlab.atp-fivt.org/courses-public/db2023-supplementary/global/-/raw/main/practice/seminars/08-triggers/img/img_1.png)

##### Алгоритм создания

1. Создание хранимой функции, которая возвращает специальный типа `TRIGGER`.
2. Создание непосредственно триггера, который запускает функцию из п.1

##### Функции для триггеров

* Не принимают ничего на вход
* Возвращают тип `TRIGGER`
* Могут использовать специальные атрибуты вида `TG_variable`

##### Специальные переменные для использования в триггерах

* `NEW` – переменная типа `RECORD`, содержащая новую строку `UPDATE` / `INSERT` операций. `NULL` для `DELETE`
* `OLD` – переменная типа `RECORD`, содержащая старую строку `UPDATE` / `DELETE` операций. `NULL` для `INSERT`
* `TG_WHEN` – переменная типа `TEXT`, указывающая на время срабатывания триггера: `BEFORE`, `AFTER`, `INSTEAD OF`
* `TG_LEVEL` – переменная типа `TEXT`, соответствующая типу триггера по уровню срабатывания: `ROW`, `STATEMENT`
* `TG_OP` – переменная типа `TEXT`, соответствующая типу операции, на которую был вызван триггер: `INSERT`, `DELETE` , `UPDATE`, `TRUNCATE`
* `TG_TABLE_NAME` – переменная типа `NAME`, соответствующая таблице, которая вызвала срабатывание триггера
* `TG_TABLE_SCHEMA` – переменная типа `NAME`, соответствующая схеме, в которой хранится таблица, которая вызвала срабатывание триггера

##### Синтаксис создания триггера

```postgresql
CREATE [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] } 
    ON table_name
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( condition ) ]
    EXECUTE { FUNCTION | PROCEDURE } function_name ( arguments )

where event can be one of:
    
    INSERT
    UPDATE [ OF column_name [, ... ] ] DELETE
    TRUNCATE
```

##### Пример

```postgresql
CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE FUNCTION log_account_update();
```

Триггеры создаются вне схем, в привязке к конкретной таблице базы данных. Удаляются тоже с указанием таблицы, на которую триггер создавался:

```postgresql
DROP TRIGGER [ IF EXISTS ] name ON table_name [ CASCADE | RESTRICT ]
```