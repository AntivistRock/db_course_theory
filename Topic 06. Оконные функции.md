### Оконные функции

#### Теор. справка

Свойства аналитических (оконных) функций:

* Оконная функция ***f***: столбец промежуточного результата вычисления ---> столбец
* Используются **только в** разделах `ORDER BY` и `SELECT`, выполняющих завершающую обработку логического промежуточного результата.
* Действуют **подобно агрегатным функциям**, но не уменьшают степень детализации.
* Агрегируют данные порциями.

#### Синтаксис

```postgresql
function_name(expression) OVER (
    [ <PARTITION BY clause> ]     -- окно
    [ <ORDER BY clause> ]         -- сортировка
    [ <ROWS or RANGE clause> ]    -- границы окна
)
```

В **отличие от** обычного запроса, **в оконном** разбиваем множество строк на блоки, внутри которых считаем необходимые агрегаты.

![img](https://gitlab.atp-fivt.org/courses-public/db2023-supplementary/global/-/raw/main/practice/seminars/06-window-functions/img/img.png)

#### Пример

Как сравнить з.п. каждого сотрудника со средней зп его отдела:

```postgresql
SELECT
    depname,
    empno,
    salary,
    avg(salary) OVER (PARTITION BY depname)
FROM
	empsalary
```

Первые три столбца извлекаются непосредственно из таблицы `empsalary`, при этом для каждой строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычисленное по всем строкам, имеющим то же значение `depname`, что и текущая строка. (Фактически среднее вычисляет та же обычная, не оконная функция `avg`, но предложение `OVER` превращает её в оконную, так что её действие ограничивается рамками окон.)

#### Использование `OVER`

* Определяет набор строк, которые будет использовать оконная функция, включая сортировку данных.
* В выражении, которое задает оконную функцию, инструкция `OVER` ограничивает наборы строк с одинаковыми значениями в поле, по которому идет разделение.

#### Правила секционирования

* `PARTITION BY` - отвечает за критерий секционирования
  * Логически разбивает множество на группы по критериям.
  * Аналитические функции применяются к группам независимо.
  * **Если не указать конструкцию секционирования, все множество считается одной группой.**
  
* `ORDER BY`
  * Задает критерий сортировки внутри каждой группы.
  * **Агрегатные функции** в отсутствие конструкции `ORDER BY` **вычисляются по всем строкам группы**, и одно и то же значение выдается для каждой строки, т.е. функция используется как итоговая.
  * Если **агрегатная функция** используется с конструкцией `ORDER BY`, то **она вычисляется по текущей строке и всем строкам до неё**, т.е. функция используется как оконная. (**вычисляется нарастающий итог**)
  
* `ROWS | RANGE` - дополнительные ограничения на диапазон строк окна (обязательно присутствие `ORDER BY`)
  
  * `ROWS` (по строкам) - позволяет **вручную** определять **границу окна**; умеет работать с `PRECEDING` / `FOLLOWING`
  * `RANGE` (по значениям из `ORDER BY`, формируется суб-окно) - достаточно близко к предыдущему, но все же не то (профессиональное мнение Александра Фаритовича: “Понятия не имею, когда это можно использовать”); Но использование `RANGE CURRENT ROW` после `ORDER BY` позволяет избавиться от нарастающего итога; не умеет работать с `PRECEDING` / `FOLLOWING`.
  * По умолчанию рассматривает от `UNBOUNDED PRECEDING` до `CURRENT ROW`. (`UNBOUNDED PRECEDING/FOLLOWING` — рассматриваем вплоть до конца/начала окна)
  * Строки выбираем в рамках окна, но при необходимости обращения к предыдущим/последующим строкам, можем вручную прописать так, чтобы может выходило за пределы окна.
  
  ![img](https://gitlab.atp-fivt.org/courses-public/db2023-supplementary/global/-/raw/main/practice/seminars/06-window-functions/img/img_4.png)

#### Классификация оконных функций

1. Агрегирующие (`sum`, `avg`, `min`, `max`, `count`)

2. Ранжирующие:

   * `row_number()` - нумеруем каждую строку окна последовательности с шагом 1
   * `rank()` - ранжируем каждую строку окна с разрывом в нумерации при равенстве значений
   * `dense_rank()` - ранжируем каждую строку окна без разрывов в нумерации при равенстве значений.

3. Смещения:

   * `lag(attr, offset (сдвиг), default_value(дефолтное значение в случае, если наша строка окажется первой))` – предыдущее значение со сдвигом
   *  `lead(attr, offset, default_value)` - след. значение со сдвигом
   * `first_value` - первое значение в окне по текущую строку
   *  `last_value` - последнее значение в окне с первой по текущую строку

   ```postgresql
   SELECT 
       BusinessEntity, 
       SalesYear, 
       CurrentQuota,
       LAG(CurrentQuota, 1, 0) OVER (ORDER BY SalesYear) AS PrevQuota,
       LEAD(CurrentQuota, 1, 0) OVER (ORDER BY SalesYear) AS NextQuota
   FROM 
       SalesPersonQuotaHistory
   WHERE 
       BusinessEntityID = 275;
   
   ```

   ![img](https://gitlab.atp-fivt.org/courses-public/db2023-supplementary/global/-/raw/main/practice/seminars/06-window-functions/img/img_6.png)

#### Фильтрация по результатам вычисления оконной функции

Если необходимо отфильтровать или сгруппировать строки после вычисления оконных функций, можно использовать вложенный запрос. Например:

```postgresql
SELECT 
    depname, 
    empno, 
    salary, 
    enroll_date
FROM (
    SELECT 
        depname,
        empno,
        salary,
        enroll_date,
        rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
    FROM 
        empsalary
) AS ss
WHERE 
    pos < 3;
```

Данный запрос покажет только те строки внутреннего запроса, у которых `rank` (порядковый номер) меньше 3.

#### Именованные вызовы оконных функций

Когда в запросе вычисляются несколько оконных функций для одинаково определённых окон, конечно можно написать для каждой из них отдельное предложение `OVER`, но при этом оно будет дублироваться, что неизбежно будет провоцировать ошибки. Поэтому лучше определение окна выделить в предложение `WINDOW`, а затем ссылаться на него в `OVER`. Например:

```postgresql
SELECT 
    sum(salary) OVER w, 
    avg(salary) OVER w
FROM 
    empsalary
WINDOW 
    w AS (PARTITION BY depname ORDER BY salary DESC);

```